(()=>{"use strict";window.Graph=class{constructor({directed:t,showDistance:i,showGrid:s}){this.board=new class{constructor(t,i,s,e){this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),this.radius=s||20,this.fontSize=e||25,this.clientPosition={x:0,y:0},this.buttons=0,this.shift=!1,this.selector="",this.canvas.width=t||300,this.canvas.height=i||400,this.init()}init(){this.canvas.onmousemove=t=>{this.clientPosition={x:t.clientX-this.canvas.offsetLeft+window.scrollX,y:t.clientY-this.canvas.offsetTop+window.scrollY},this.buttons=t.buttons,this.shift=t.shiftKey},window.onresize=t=>{this.selector&&this.appendTo(this.selector)}}appendTo(t){this.selector=t;const i=document.querySelector(t);i.innerHTML="",i.append(this.canvas),this.canvas.width=i.offsetWidth,this.canvas.height=i.offsetHeight}drawCircle(t,i,s){this.context.lineWidth=5,this.context.beginPath(),this.context.arc(t,i,s,0,2*Math.PI),this.context.stroke(),this.context.fillStyle="#fff",this.context.fill(),this.context.fillStyle="#000",this.context.lineWidth=1}drawNode(t,i,s,e){e&&(this.context.strokeStyle="#dc3545"),this.drawCircle(t,i,this.radius),this.context.font=`${this.fontSize}px Arial`,this.context.textAlign="center",this.context.fillText(s,t,i+this.fontSize/2),this.context.strokeStyle="#000"}drawLine(t,i,s,e){this.context.lineWidth=2,this.context.beginPath(),this.context.moveTo(t,i),this.context.lineTo(s,e),this.context.stroke(),this.context.lineWidth=1}drawDirected(t,i,s,e){const h=Math.atan2(i-e,t-s),o={x:s+this.radius*Math.cos(h),y:e+this.radius*Math.sin(h)},n=o.x+this.radius*Math.cos(h)*Math.pow(3,.5)/2,a=o.y+this.radius*Math.sin(h)*Math.pow(3,.5)/2,r={x:n+this.radius/2*Math.cos(h-Math.PI/2),y:a+this.radius/2*Math.sin(h-Math.PI/2)},d={x:n+this.radius/2*Math.cos(h+Math.PI/2),y:a+this.radius/2*Math.sin(h+Math.PI/2)};this.context.lineWidth=5,this.context.beginPath(),this.context.moveTo(o.x,o.y),this.context.lineTo(r.x,r.y),this.context.lineTo(d.x,d.y),this.context.lineTo(o.x,o.y),this.context.fillStyle="#000",this.context.stroke(),this.context.fill(),this.context.lineWidth=1}drawDistance(t,i,s,e){const h={x:(t+s)/2,y:(i+e)/2},o=Math.sqrt(Math.pow(t-s,2)+Math.pow(i-e,2));this.context.fillStyle="#000",this.context.beginPath(),this.context.fillText(parseInt(o/100),h.x,h.y),this.context.textAlign="center",this.context.fillStyle="#fff"}drawHorizontal(t){this.context.strokeStyle="#fff",this.context.beginPath(),this.context.moveTo(0,t),this.context.lineTo(this.canvas.width,t),this.context.stroke(),this.context.strokeStyle="#000"}drawVertical(t){this.context.strokeStyle="#fff",this.context.beginPath(),this.context.moveTo(t,0),this.context.lineTo(t,this.canvas.height),this.context.stroke(),this.context.strokeStyle="#000"}drawGrid(){for(let t=0;t<=this.canvas.height;t+=2*this.radius)this.drawHorizontal(t);for(let t=0;t<=this.canvas.width;t+=2*this.radius)this.drawVertical(t)}clear(){this.context.fillStyle="#f4f8ff",this.context.fillRect(0,0,this.canvas.width,this.canvas.height),this.context.fill(),this.context.fillStyle="#000"}},this.nodes=[],this.edges=[],this.functions=[],this.target=null,this.directed=t,this.showDistance=i,this.showGrid=s,this.init()}init(){this.board.canvas.ondblclick=t=>{this.target||this.addNode(this.nodes.length+1,this.board.clientPosition.x,this.board.clientPosition.y)},this.board.canvas.addEventListener("mousemove",(t=>{const{x:i,y:s}=this.board.clientPosition;document.body.style.cursor="unset",this.nodes.forEach((t=>{this.equalPoint(i,t.x)&&this.equalPoint(s,t.y)&&(this.target=this.target||t)})),this.target&&(this.board.buttons&&this.board.shift?document.body.style.cursor="move":document.body.style.cursor="pointer",this.board.shift||1===this.board.buttons||this.equalPoint(i,this.target.x)&&this.equalPoint(s,this.target,s)||(this.target=null))})),this.update()}update(){this.draw(),this.checkAddEdge(),this.updateNodes(),setTimeout((()=>{this.update()}),1e3/60)}addNode(t,i,s){const e={x:i||Math.floor(Math.random()*this.board.canvas.width),y:s||Math.floor(Math.random()*this.board.canvas.height),label:t,move:10};this.nodes.push(e)}addEdge(t,i){const s={from:t,to:i};this.edges.push(s),this.target=null}removeNode(t){this.nodes=this.nodes.filter((i=>i.label!==t))}removeEdge(t){const{from:i,to:s}=t;this.edges=this.edges.filter((t=>t.from!==i||t.to!==s))}draw(){this.board.clear(),this.showGrid&&this.board.drawGrid(),this.drawEdges(),this.drawLine(),this.drawNodes()}drawNodes(){this.nodes.forEach((t=>{this.board.drawNode(t.x,t.y,t.label,this.target?.label===t.label)}))}updateNodes(){this.nodes=this.nodes.map((t=>this.board.buttons&&!this.board.shift&&this.target&&this.target.label===t.label?(this.target=this.toClientPosition(t),this.toClientPosition(t)):this.exchange(t)))}exchange(t){return t.move>=0?{...t,x:t.x+.1,y:t.y+.1,move:t.move-.1}:t.move>=-10?{...t,x:t.x-.1,y:t.y-.1,move:t.move-.1}:{...t,move:10}}toClientPosition(t){return{...t,x:this.board.clientPosition.x,y:this.board.clientPosition.y}}drawEdges(){this.edges.forEach((t=>this.drawEdge(t)))}drawLine(){if(!this.board.shift||1!==this.board.buttons||!this.target)return;const{x:t,y:i}=this.board.clientPosition;this.board.drawLine(this.target.x,this.target.y,t,i)}checkAddEdge(){if(!this.target)return;if(!this.board.shift)return;const{x:t,y:i}=this.board.clientPosition;this.nodes.forEach((s=>{this.target&&s.label!==this.target.label&&this.equalPoint(t,s.x)&&this.equalPoint(i,s.y)&&(this.addEdge(this.target.label,s.label),this.target=null)}))}drawEdge(t){let i=null,s=null;if(this.nodes.forEach((e=>{e.label==t.from&&(i=e),e.label==t.to&&(s=e)})),!i||!s)return this.removeEdge(t);this.board.drawLine(i.x,i.y,s.x,s.y),this.directed&&this.board.drawDirected(i.x,i.y,s.x,s.y),this.showDistance&&this.board.drawDistance(i.x,i.y,s.x,s.y)}exportMatrix(){const t=[],i=[];for(let t=0;t<=this.nodes.length;t++)i.push(0);for(let s=0;s<=this.nodes.length;s++)t.push([...i]);return this.edges.forEach((i=>{t[i.from][i.to]++,this.directed||t[i.to][i.from]++})),t}equalPoint(t,i){return Math.abs(t-i)<=this.board.radius}neighbours(t){return this.exportMatrix()[t].map(((t,i)=>t?i:t)).filter((t=>t))}deepFirstSearch(t){const i=new class{constructor(){this.__data__=[]}push(t){this.__data__.push(t)}pop(){return this.__data__.pop()}empty(){return!this.__data__.length}top(){return this.__data__[this.__data__.length-1]}},s=[];i.push(t);const e=[];for(;!i.empty();){const t=i.pop();if(s[t])continue;s[t]=!0;const h=this.neighbours(t);e.push({u:t,stack:[...i.__data__],marked:[...s],neigh:h}),h.forEach((t=>i.push(t)))}return e}}})();